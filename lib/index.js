// ==========================================================================
// Project:   Tiki
// Copyright: Â©2009 Apple Inc.
// ==========================================================================
/*globals exports browser userAgent platformPackages platform ready unload timer */

"export browser userAgent platformPackages platform console ready unload timer";

var YES = true, NO = false;

// This file overrides the default package_exports generated by the build 
// tools.  We have to generate the index this way for tiki because it is 
// included automatically by other modules which are themselves required for
// this module to function.

// The tiki index module is imported automatically by all modules as the 
// "tiki" free-variable.  You can access this free variable to access platform
// specific APIs.

// note: must specify tiki explicitly b/c this will be loaded by boostrap
// require.

// ..........................................................
// BROWSER DETECTION
// 

userAgent = navigator.userAgent.toLowerCase();

var version = (userAgent.match( /.+(?:rv|it|ra|ie)[\/: ]([\d.]+)/ ) || [])[1];

browser = {
  
  /** The current browser version */
  version: version,
  
  /** non-zero if webkit-based browser */
  safari: (/webkit/).test( userAgent ) ? version : 0,
  
  /** non-zero if this is an opera-based browser */
  opera: (/opera/).test( userAgent ) ? version : 0,
  
  /** non-zero if this is IE */
  msie: (/msie/).test( userAgent ) && !(/opera/).test( userAgent ) ? version : 0,
  
  /** non-zero if this is a miozilla based browser */
  mozilla: (/mozilla/).test( userAgent ) && !(/(compatible|webkit)/).test( userAgent ) ? version : 0,
  
  /** non-zero if this is mobile safari */
  mobileSafari: (/apple.*mobile.*safari/).test(userAgent) ? version : 0,
  
  /** non-zero if we are on windows */
  windows: !!(/(windows)/).test(userAgent),
  
  /** non-zero if we are on a mac */
  mac: !!((/(macintosh)/).test(userAgent) || (/(mac os x)/).test(userAgent)),
  
  language: (navigator.language || navigator.browserLanguage).split('-', 1)[0]
};

browser.isOpera = !!browser.opera;
browser.isIe = browser.msie;
browser.isIE = browser.msie;
browser.isSafari = browser.safari;
browser.isMobileSafari = browser.mobileSafari;
browser.isMozilla = browser.mozilla;
browser.isWindows = browser.windows;
browser.isMac = browser.mac;

/**
  The current browser name.  This is useful for switch statements. 
*/
browser.current = 
  browser.msie ? 'msie' : 
  browser.mozilla ? 'mozilla' : 
  browser.safari ? 'safari' : 
  browser.opera ? 'opera' : 'unknown' ;

// ..........................................................
// PLATFORM SPECIFIC INCLUDES
// 

// current platform packages in order.  usually the curent browser + 'browser'
platformPackages = ['tiki/'+browser.current];

// cache turns [packageId, moduleId] into joined
var idCache = {};
function _joinId(moduleId, packageId, sep) {
  var sepCache = idCache[sep], cache, ret;
  if (!sepCache) sepCache = idCache[sep] = {};
  if (!(cache = sepCache[packageId])) cache = sepCache[packageId] = {};

  ret = cache[moduleId];
  if (!ret) ret = cache[moduleId] = (packageId + sep + moduleId);
  return ret ;
}

/**
  substitute for "require".  This will return the named module from withing
  the current platform.  This will check each platform independently.
  
  @param {String} moduleId module id to load
  @returns {Hash} platform-specific module, if found.
*/
platform = function(moduleId) {
  var packageIds = exports.platformPackages, 
      len = packageIds ? packageIds.length : 0,
      idx, id;
  for(idx=0;idx<len;idx++) {
    id = _joinId(packageIds[idx], moduleId, ':');
    if (require.loader.ready(id)) return require(id);
  }

  // just try a normal require on local package
  return require(_joinId(moduleId, 'platform', '/')); 
};

// do this manually so the console require below will work
exports.platform = platform; 
exports.platformPackages = platformPackages;

// ..........................................................
// CONSOLE
// 

// we can only add this AFTER platform is defined
console = require('logger').console;
timer   = require('timer'); // should not need this

// ..........................................................
// READY/UNLOAD
// 

var Invocation = require('invocation').Invocation ;

// called when the document becomes ready.  work through the queue...
function _ready() {
  var queue = ready.queue, 
      mainQ = ready.mainQ,
      len   = queue.length,
      inv, idx;

  ready.isReady = ready.scheduled = YES ;
  ready.queue = []; // ok to alloc since it is usually only called once
  ready.mainQ = [];
  
  for(idx=0;idx<len;idx++) {
    inv = queue[idx];
    inv.invoke();
    inv.release(); // return to pool
  }

  // after calling ready handlers, invoke any main functions to start the app
  len = mainQ.length;
  for(idx=0;idx<len;idx++) {
    inv = mainQ[idx];
    inv.invoke();
    inv.release(); // return to pool
  }
}

/**
  Call to register methods you want run when the system is ready for the app
  to run.
*/
ready = function(target, method, args) {
  if (ready.isReady) {
    Invocation.invoke(target, method, arguments, 2);

  // if not ready yet, schedule in queue
  } else {
    if (!ready.scheduled) tiki.platform('event').ready(_ready);
    ready.scheduled = YES ;
    ready.queue.push(Invocation.create(target, method, arguments, 2));
  }
  
  return this ;
};

ready.isReady = NO ;
ready.queue   = [] ;
ready.scheduled = NO ;
ready.mainQ   = [] ; // invocations for main. called after ready

ready.main = function(target, method, args) {
  if (ready.isReady) {
    Invocation.invoke(target, method, arguments, 2);
    
  } else {
    if (!ready.scheduled) tiki.platform('event').ready(_ready);
    ready.scheduled = YES ;
    ready.mainQ.push(Invocation.create(target, method, arguments, 2));
  }
  
  return this ;
};

// ..........................................................
// UNLOAD HANDLER
// 

function _unload() {
  var queue = unload.queue, 
      len   = queue.length,
      inv, idx;

  unload.isUnloaded = unload.scheduled = YES ;
  unload.queue = [];
  
  for(idx=0;idx<len;idx++) {
    inv = queue[idx];
    inv.invoke();
    inv.release(); // return to pool
  }
}

/**
  Call to register methods you want run when the system is about to unload.
*/
unload = function(target, method, args) {
  if (unload.isUnloaded) {
    Invocation.invoke(target, method, arguments, 2);
    
  } else {
    if (!unload.scheduled) tiki.platform('event').unload(_unload);
    unload.scheduled = YES;
    unload.queue.push(Invocation.create(target, method, arguments, 2));
  }
  
  return this ;
};

unload.isUnloaded = NO;
unload.queue      = [];
unload.scheduled  = NO;

