// ==========================================================================
// Project:   Tiki - CommonJS Runtime
// Copyright: Â©2009-2010 Apple Inc. All rights reserved.
// License:   Licened under MIT license (see __preamble__.js)
// ==========================================================================

// This file overrides the default package_exports generated by the build 
// tools.  We have to generate the index this way for tiki because it is 
// included automatically by other modules which are themselves required for
// this module to function.

// The tiki index module is imported automatically by all modules as the 
// "tiki" free-variable.  You can access this free variable to access platform
// specific APIs.

// note: must specify tiki explicitly b/c this will be loaded by boostrap
// require.


"use exports T_ERROR T_OBJECT T_NULL T_CLASS T_HASH T_FUNCTION T_UNDEFINED T_NUMBER T_BOOL T_ARRAY T_STRING T_BOOLEAN YES NO isArray typeOf $A generateGuid guidFor mixin setupDisplayNames beget extend K console Retainable Invocation Logger Promise ready unload";

// ..........................................................
// STANDARD TYPES
// 

// define standard type constants
var T_ERROR     = 'error',
    T_OBJECT    = 'object',
    T_NULL      = 'null',
    T_CLASS     = 'class',
    T_HASH      = 'hash',
    T_FUNCTION  = 'function',
    T_UNDEFINED = 'undefined',
    T_NUMBER    = 'number',
    T_BOOL      = 'boolean',
    T_ARRAY     = 'array',
    T_STRING    = 'string',
    T_BOOLEAN   = 'boolean',
    
    YES         = true,
    NO          = false,
    K           = function() {}; // empty function

exports.T_ERROR     = T_ERROR;
exports.T_OBJECT    = T_OBJECT;
exports.T_NULL      = T_NULL;
exports.T_CLASS     = T_CLASS;
exports.T_HASH      = T_HASH;
exports.T_FUNCTION  = T_FUNCTION;
exports.T_UNDEFINED = T_UNDEFINED;
exports.T_NUMBER    = T_NUMBER;
exports.T_BOOL      = T_BOOL;
exports.T_ARRAY     = T_ARRAY;
exports.T_STRING    = T_STRING;
exports.T_BOOLEAN   = T_BOOLEAN;
exports.YES         = YES;
exports.NO          = NO;

// ..........................................................
// ARRAY UTILITIES
// 


var TMP_ARY = [];

/**
  Returns true if the passed item is an array.  Works regardless of source
  of array.
*/
var isArray = function(obj) {
  if (obj && obj.isArray) return true; // fast path
  if (!obj) return false;
  if (T_UNDEFINED !== typeof obj.length) {
    if ((typeof obj !== T_FUNCTION) && (typeof obj !== T_STRING) && (obj.constructor !== String)) return true;
  }
  // TODO: add proper check that works across windows...
  return false ;  
};
exports.isArray = isArray;

Array.prototype.isArray = true ;
  
/**
  Converts the passed object to an Array.  If the object appears to be 
  array-like, a new array will be cloned from it.  Otherwise, a new array
  will be created with the item itself as the only item in the array.
  
  @param object {Object} any enumerable or array-like object.
  @returns {Array} Array of items
*/
exports.$A = function A(obj) {
  // null or undefined -- fast path
  if ((obj === null) || (obj === undefined)) return [] ;
  
  // primitive -- fast path
  if (obj.slice instanceof Function) {
    // do we have a string?
    if (typeof(obj) === 'string') return [obj] ;
    else return obj.slice() ;
  }
  
  // enumerable -- fast path
  if (obj.toArray) return obj.toArray() ;
  
  // if not array-like, then just wrap in array.
  if (!isArray(obj)) return [obj];
  
  // when all else fails, do a manual convert...
  var ret = [], len = obj.length;
  while(--len >= 0) ret[len] = obj[len];
  return ret ;
};

// ..........................................................
// TYPE DETECTION & GUIDS
// 

/**
  Returns a consistant type for the passed item.

  Use this instead of the built-in typeOf() to get the type of an item. 
  It will return the same result across all browsers and includes a bit 
  more detail.  Here is what will be returned:

  | Return Value Constant | Meaning |
  | SC.T_STRING | String primitive |
  | SC.T_NUMBER | Number primitive |
  | SC.T_BOOLEAN | Boolean primitive |
  | SC.T_NULL | Null value |
  | SC.T_UNDEFINED | Undefined value |
  | SC.T_FUNCTION | A function |
  | SC.T_ARRAY | An instance of Array |
  | SC.T_CLASS | A SproutCore class (created using SC.Object.extend()) |
  | SC.T_OBJECT | A SproutCore object instance |
  | SC.T_HASH | A JavaScript object not inheriting from SC.Object |

  @param item {Object} the item to check
  @returns {String} the type
*/  
exports.typeOf = function typeOf(item) {
  if (item === undefined) return T_UNDEFINED ;
  if (item === null) return T_NULL ; 
  
  var ret = typeof(item) ;
  if (ret == "object") {
    if (isArray(item)) ret = T_ARRAY ;
    else if (item instanceof Function) {
      ret = item.isClass ? T_CLASS : T_FUNCTION ;
    } else if ((item instanceof Error) || item.isError) ret = T_ERROR;
    else if (item.isObject) ret = T_OBJECT ;
    else if (item.isClass) ret = T_CLASS;
    else if (item.constructor === Object) ret = T_HASH;
    else if (item.constructor === Number) ret = T_NUMBER;
    else if (item.constructor === String) ret = T_STRING;
    else ret = T_OBJECT;

  } else if (ret === T_FUNCTION) ret = item.isClass ? T_CLASS : T_FUNCTION;
  
  return ret ;
};
  
var guidKey = "_tk_guid_" + new Date().getTime();
var _nextGUID = 0, _numberGuids = [], _stringGuids = [];

/**
  Generates a new guid, optionally saving the guid to the object that you
  pass in.  You will rarely need to use this method.  Instead you should
  call SC.guidFor(obj), which return an existing guid if available.

  @param {Object} obj the object to assign the guid to
  @returns {String} the guid
*/
var generateGuid = function generateGuid(obj) { 
  var ret = ("tk" + (_nextGUID++)); 
  if (obj) obj[guidKey] = ret ;
  return ret ;
};
exports.generateGuid = generateGuid;

/**
  Returns a unique GUID for the object.  If the object does not yet have
  a guid, one will be assigned to it.  You can call this on any object,
  SC.Object-based or not, but be aware that it will add a _guid property.

  You can also use this method on DOM Element objects.

  @param obj {Object} any object, string, number, Element, or primitive
  @returns {String} the unique guid for this instance.
*/
exports.guidFor = function guidFor(obj) {
  
  // special cases where we don't want to add a key to object
  if (obj === undefined) return "(undefined)" ;
  if (obj === null) return '(null)' ;
  if (obj === Object) return '(Object)';
  if (obj === Array) return '(Array)';
  
  if (obj[guidKey]) return obj[guidKey] ;

  switch(typeof obj) {
    case T_NUMBER:
      return (_numberGuids[obj] = _numberGuids[obj] || ("nu" + obj));
    case T_STRING:
      return (_stringGuids[obj] = _stringGuids[obj] || ("st" + obj));
    case T_BOOL:
      return obj ? "(true)" : "(false)" ;
    default:
      return generateGuid(obj);
  }
};

// ..........................................................
// OBJECT EXTENSION
// 

// primitive mixin
function _mixin(t, items, skip) {
  
  // copy reference to target object
  var len    = items.length,
      target = t || {},
      idx, options, key, src, copy;

  for (idx=skip; idx < len; idx++ ) {
    if (!(options = items[idx])) continue ;
    for(key in options) {
      if (!options.hasOwnProperty(key)) continue ;

      src  = target[key];
      copy = options[key] ;
      if (target===copy) continue ; // prevent never-ending loop
      if (copy !== undefined) target[key] = copy ;
    }
  }
  
  return target;
}

/**
  Copy the passed properties onto the first parameter.
  
  @param {Hash} t the target object to mixin to
  @param {Hash..} one or more hashes to mix in
  @returns {Hash} the first parameter
*/
exports.mixin = function(t) {
  return _mixin(t, arguments, 1);
};

// used to beget new objects
var K_ = function() {},
    Kproto_ = K_.prototype;

/**
  Take the named object, beget a new instance using prototype inheritence
  then copy props onto it.
  
  @param {Hash} t the object to beget
  @param {Hash..} hashes optional zero or more hashes to copy props from
  @returns {Hash} the begotten object
*/
var beget = function(t) {
  var ret ;
  
  // primitives cannot beget()
  if (T_OBJECT !== typeof(t)) return t ;
  
  K_.prototype = t ;
  ret = new K_();
  K_.prototype = Kproto_;
  
  return _mixin(ret, arguments, 1);
};
exports.beget = beget;

// default __init method.  calls init() if defined.  can be overloaded.
var __init = function(args) {
  var init;
  if (init = this.init) init.apply(this, args);  
};

// generate a new constructor function
function _const() {
  return function() {
    this.__init(arguments);
    return this;
  };
}

/**
  Accepts a constructor function and returns a new constructor the extends 
  the passed value.  The new constructor will pass any constructor methods 
  along to an init() method on the prototype, if it is defined.

  Any additional passed arguments will be copied onto the object.
  
  You can also just pass hashes and we'll make up a constructor for you.
  
  @param {Function} F the constructor function to extend
  @param {Hash..} hashes optional zero or more hashes to copy props from
  @returns {Function} the new subclass
*/
exports.extend = function(F) {
  var Ret = _const(), prot;
   
  if (T_FUNCTION === typeof F) {
    prot = Ret.prototype = beget(F.prototype);
    if (!prot.__init) prot.__init = __init; // needed for setup
    _mixin(prot, arguments, 1);

  // build a NEW object.
  } else {
    prot = Ret.prototype = _mixin({ __init: __init }, arguments, 0);
  }
  
  prot.constructor = Ret ;
  
  return Ret;
};

// ..........................................................
// DEBUG MARKING

// 
/**
  Iterate over a property, setting display names on functions as needed.
  Call this on your own exports to setup display names for debugging.
*/
var setupDisplayNames = function(obj, root) {
  var a = TMP_ARY;
  a[0] = root;
  
  var k,v;
  for(k in obj) {
    if (!obj.hasOwnProperty(k)) continue ;
    v = obj[k];
    if ('function' === typeof v) {
      a[1] = k;
      v.displayName = a.join('.');
    }
  }
  
  a.length = 0;
  return obj;
};
exports.setupDisplayNames = setupDisplayNames;

setupDisplayNames(exports, 'tiki');

// ..........................................................
// Public API for tiki
// 

exports.Retainable = require('retainable');
exports.Invocation = require('invocation');
exports.Logger     = require('logger');
exports.Promise    = require('promise');

// ..........................................................
// BROWSER READY/UNLOAD
// 

// These two methods are used by tiki to do some initial setup/teardown.  
// We also expose them as part of the global API so that other libraries can
// avoid reimplementing the same basic logic

var Invocation = require('invocation'),
    handlers   = {}, ready, unload;

function queueListener(src, status, queueName, target, method, args) {
  var inv ;
  
  // if ready, invoke immediately.  otherwise schedule
  if (src[status]) {
    if (target && target.isInvocation) target.invoke();
    else Invocation.invoke(target, method, args, 2);
    
  } else {
    if (target && target.isInvocation) inv = target.retain();
    else inv = Invocation.create(target, method, args, 2);
    if (!src[queueName]) src[queueName] = [];
    src[queueName].push(inv);
    src.schedule(); // only used by unload
  }
}

function flushQueue(src, queueName) {
  var q = src[queueName],
      len = q ? q.length : 0,
      idx, inv;
    
  for(idx=0;idx<len;idx++) {
    inv = q[idx];
    inv.invoke();
    inv.release(); // release to return to pool
  }
  src[queueName] = null;
}

/**
  Register a method you want to run when the browser has finished parsing the
  main HTML document body (but possibly before any images have loaded).  You
  can either pass target/method/arguments or an Invocation object.  If the 
  document is ready, the method will be invoked immediately.
  
  @param {Object|Invocation} target the target to call or an invocation
  @param {Function|String} method the function or method to invoke
  @param {Object...} args zero or more additional arguments to invoke
*/
ready = function(target, method, args) {
  queueListener(ready, 'isReady', 'queue', target, method, arguments);
};
exports.ready = ready;

/**
  Register a main function you want to run when the browser is ready. You
  can either pass target/method/arguments or an Invocation object.  If the 
  document is ready, the method will be invoked immediately.
  
  @param {Object|Invocation} target the target to call or an invocation
  @param {Function|String} method the function or method to invoke
  @param {Object...} args zero or more additional arguments to invoke
*/
ready.main = function(target, method, args) {
  queueListener(ready, 'isReady', 'mqueue', target, method, arguments);
};

// becomes true when ready fires
ready.isReady = false; 

// called when the document becomes ready
ready.fire = function() {
  if (ready.isReady) return ; // nothing to do
  ready.isReady = true ; 
  
  // first cleanup any listeners so they don't fire again
  if (ready.cleanup) ready.cleanup();
  ready.cleanup = null; 
  
  // flush any pending queues
  flushQueue(ready, 'queue');
  flushQueue(ready, 'mqueue');
};
ready.fire.displayName = 'ready.fire()';

// ready is always scheduled so this method can do nothing
ready.schedule = K;

// always listen for onready event - detect based on platform
// those code is derived from jquery 1.3.1
// server-side JS
if (T_UNDEFINED === typeof document) {
  // TODO: handler server-side JS cases here

// Mozilla, Opera, webkit nightlies
} else if (document.addEventListener) {

  // cleanup handler to be called whenever any registered listener fires
  // should prevent additional listeners from firing
  ready.cleanup = function() {
    document.removeEventListener('DOMContentLoaded', ready.fire, false);
    document.removeEventListener('load', ready.fire, false);
  };
  
  // register listeners
  document.addEventListener('DOMContentLoaded', ready.fire, false);
  document.addEventListener('load', ready.fire, false);
  
// IE
} else if (document.attachEvent) {
  
  // cleanup handler - should cleanup all registered listeners
  ready.cleanup = function() {
    document.detachEvent('onreadystatechange', ready.fire);
    document.detachEvent('onload', ready.fire);
    ready.ieHandler = null; // this will stop the ieHandler from firing again
  };
  
  // listen for readystate and load events
  document.attachEvent('onreadystatechange', ready.fire);
  document.attachEvent('onload', ready.fire);
  
  // also if IE and no an iframe, continually check to see if the document is
  // ready
  // NOTE: DO NOT CHANGE TO ===, FAILS IN IE.
  if ( document.documentElement.doScroll && window == window.top ) {
    ready.ieHandler = function() {

      // If IE is used, use the trick by Diego Perini
      // http://javascript.nwbox.com/IEContentLoaded/
      if (ready.ieHandler && !ready.isReady) {
        try {
          document.documentElement.doScroll("left");
        } catch( error ) {
          setTimeout( ready.ieHandler, 0 );
          return;
        }
      }

      // and execute any waiting functions
      ready.fire();
    };

    ready.ieHandler();
  }
  
}



/**
  Register a method to execute just before the browser unloads.  Often used
  to cleanup any references to 'window' or 'document' to prevent a memory 
  leak.
  
  
  @param {Object|Invocation} target the target to call or an invocation
  @param {Function|String} method the function or method to invoke
  @param {Object...} args zero or more additional arguments to invoke
*/
unload = function(target, method, args) {
  queueListener(unload, 'isUnloading', 'queue', target, method, arguments);
};
exports.unload = unload;

// becomes true when unload fires
unload.isUnloading = false;

// call on unload
unload.fire = function() {
  if (unload.isUnloading) return;
  unload.isUnloading = true;
  
  if (unload.cleanup) unload.cleanup();
  unload.cleanup = null;

  // flush any pending queues
  var q = unload.queue,
      len = q ? q.length : 0,
      idx, inv;
    
  for(idx=0;idx<len;idx++) {
    inv = q[idx];
    inv.invoke();
    inv.release(); // release to return to pool
  }
  unload.queue = null;
  
};

unload.schedule = function() {
  if (unload.isScheduled) return ;
  unload.isScheduled = true;
  
  if (T_UNDEFINED = typeof document) {
    // TODO: Handle server-side JS mode
    
  } else if (document.addEventListener) {
    unload.cleanup = function() {
      document.removeEventListener('unload', unload.fire);
    };
    document.addEventListener('unload', unload.fire, false);
    
  } else if (document.attachEvent) {
    unload.cleanup = function() {
      document.detachEvent('onunload', unload.fire);
    };
    document.attachEvent('unload', unload.fire);
  }
};
