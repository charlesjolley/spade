// ==========================================================================
// Project:   Tiki - CommonJS Runtime
// Copyright: Â©2009-2010 Apple Inc. All rights reserved.
// License:   Licened under MIT license (see __preamble__.js)
// ==========================================================================
/*jslint evil:true */

var core = require('./core'),
    FUNCTION = 'function',
    STRING   = 'string';

/**
  @constructor
  
  A factory knows how to instantiate a new module for a sandbox, including 
  generating the require() method used by the module itself.  You can return
  custom factories when you install a plugin.  Your module should export
  loadFactory().
  
  The default factory here actually expects to receive a module descriptor
  as generated by the build tools.
*/

var Factory = function(moduleId, pkg) {
  this.id  = moduleId;
  this.pkg = pkg;
  this.desc = {};
};
exports.Factory = Factory;

/**
  Save the factory function to load on demand.
*/
Factory.prototype.load = function(desc, done) {
  var kind = typeof desc;
  if ((FUNCTION === kind) || (STRING === kind)) {
    this.factory = desc;
  } else {
    this.factory = desc.factory;
    delete desc.factory;
    this.desc = desc;
  }
  return done();
};

var _createRequire = function(sandbox, module) {
  
  var moduleId = module.id,
      pkg      = module.pkg;
      
  // basic synchronous require
  var req = function(moduleId, packageId) {
    return sandbox.require(moduleId, packageId, module);
  };

  // async version - packageId is optional
  req.async = function(moduleId, packageId, done) {
    var idx, len ;
    
    if (FUNCTION === typeof packageId) {
      done = packageId;
      packageId = null;
    }

    // if no arguments passed, just ask sandbox for module - which will 
    // load the associated factory without activating it
    var method =  (done.length===0) ? 'module' : 'require';
    if (core.isArray(moduleId)) {
      core.comap(moduleId, function(moduleId, done) {
        sandbox[method](moduleId, packageId, module, done);
      })(function(err, results) { 
        if (err) throw err;
        if (method === 'require') return done.apply(null, results);
        else return done();
      });
  
    } else {
      sandbox[method](moduleId, packageId, module, function(err, ret) {
        if (err) throw err;
        if (method === 'require') return done(ret);
        else return done();
      });
    }
  };
  req.load = req.async;
  
  // finds the package for a given packageId (and optional version).  If
  // you pass done called async.  Otherwise call sync.
  req.packageFor = function(packageId, done) {
    var ret = sandbox.loader.packageFor(packageId, pkg, done);
    if (!done) return ret; // otherwise return void
  };
  
  // returns the module associated with a moduleId - possibly not actually
  // running the factory yet
  req.module = function(moduleId, packageId, done) {
    if (FUNCTION === typeof packageId) {
      done = packageId;
      packageId = null;
    }
    return sandbox.module(moduleId, packageId, null, module, done);
  };

  // returns the module associated with a moduleId - possibly not actually
  // running the factory yet
  req.ready = function(moduleId, packageId, done) {
    if (FUNCTION === typeof packageId) {
      done = packageId;
      packageId = null;
    }
    return sandbox.ready(moduleId, packageId, null, module, done);
  };

  // mark main module in sandbox
  req.main = sandbox.main;
  req.sandbox = sandbox;
  
  return req;
};

/**
  Actually generates a new set of exports for the named sandbox.  The sandbox
  must return a module object that can be used to generate the factory.
  
  If the current value of the local factory is a string, then we will actually
  eval/compile the factory as well.
*/
Factory.prototype.call = function(sandbox, module) {

  // get the factory function, evaluate if needed
  var func = this.factory,
      filename = this.__filename,
      dirname  = this.__dirname;
      
  if (STRING === typeof(func)) {
    func = this.factory = exports.compile(func, this.pkg.id+':'+this.id);
  }

  // generate a nested require for this puppy
  var req = _createRequire(sandbox, module),
      exp = module.exports;
  func.call(exp, req, exp, module, filename, dirname);
  return module.exports;
};


// standard wrapper around a module.  replace item[1] with a string and join.
var MODULE_WRAPPER = [
  '(function(require, exports, module, __filename, __dirname) {',
  null,
  '\n});\n//@ sourceURL=',
  null,
  '\n'];

/**
  Evaluates the passed string.  Returns a function
*/
exports.compile = function(moduleText, moduleId) {
  var ret;
  
  MODULE_WRAPPER[1] = moduleText;
  MODULE_WRAPPER[3] = moduleId || '(unknown module)';
  
  ret = MODULE_WRAPPER.join('');
  ret = eval(ret);
  
  MODULE_WRAPPER[1] = MODULE_WRAPPER[3] = null;
  return ret;
};

exports.loadFactory = function(moduleId, pkg, desc, done) {
  var ret = new Factory(moduleId, pkg);
  ret.load(desc, function(err) { done(err, !err ? ret : null); });
};

core.displayNames(exports);
